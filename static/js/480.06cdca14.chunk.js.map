{"version":3,"file":"static/js/480.06cdca14.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../../../kooljs/kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n\n// 1. All commercial uses of the Software must:  \n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).  \n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).  \n\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  \nvar finished = []\nvar fps = 10.33\nvar signal,loop_resolver = null\nvar triggers_step\nconst callback_map=new Map()\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.type = undefined\n        this.delta_t = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.loop=undefined\n        this.activelist = []\n        this.results = new Map()\n        this.lerp_callbacks=new Map()\n    }\n    activate(id) {\n        if (this.activelist.includes(id) == false) {\n            this.activelist.push(id)\n            return true\n        }\n        return false\n    }\n    get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.results.get(index)\n    }\n}\nvar final_step,final_sub_step\n\nclass LerpChain{\n/**\n * The constructor for the LerpChain class.\n * Initializes properties related to the state and progress of the lerp chain.\n * \n * @property {Array|undefined} buffer - The buffer holding the chain data.\n * @property {Map|undefined} matrixChains - The map containing matrix chains.\n * @property {Array|undefined} progress - The progress of each chain.\n * @property {Array|undefined} lengths - The lengths of each chain.\n */\n\n    constructor(){\n        this.buffer=undefined\n        this.matrixChains=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        if(this.progress[id]==this.lengths[id]-1){\n            return true\n        }\n        else{\n            this.reset_and_update(id)\n            return(false)\n        }\n    }\n    reset_and_update(id){\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0\n        this.progress[id]+=1\n    }\n    reset(id){\n        if(lerp_registry.type[id]==2){\n            lerp_registry.results.set(id,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[id]])\n        }\n        else if(lerp_registry.type[id]==3){\n            lerp_registry.results.set(id,lerpChain_registry.matrixChains.get(id).get(0))\n        }\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0   \n        this.progress[id]=0\n    }\n    soft_reset(id){\n        final_step=this.progress[id]==this.lengths[id]-1\n        final_sub_step=lerp_registry.progress[id]>=lerp_registry.duration[id]\n        lerp_registry.activate(id)\n        if(final_step && final_sub_step){\n            this.reset(id)\n        }\n        else if(final_sub_step){\n            this.reset_and_update(id)\n        }\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=new Map()\n        this.number=undefined\n        this.render_triggers=new Map()\n        this.render_callbacks=new Map()\n    }\n   update(type, id, value){\n        constant_registry[type].set(id,value)\n        if(this.render_callbacks.has(id))  this.render_callbacks.get(id).map((l) => {\n            callback_map.get(l.id)(l.args)\n        })\n        if(this.render_triggers.has(id)) start_animations(this.render_triggers.get(id))\n     }\n    get(type,index,row){\n        if(row!=undefined){\n            this.get_row(index,row)\n        }\n        else return constant_registry[type].get(index)\n    }\n    get_row(index,row){\n        return constant_registry[\"matrix\"].get(index).get(row)\n    }\n    get_number(index){\n        return constant_registry[\"number\"].get(index)\n    }\n}\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst lerpChain_registry = new LerpChain()\nconst trigger_registry = new Map()\n// ----------------------------------------> ANIMATION <--\nvar t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\n//var triggers,triggers_step\nvar targets,allow_render, args\nasync function animate() {\n    finished=[]\n    lerp_registry.activelist.map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] <= lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                allow_render=lerp_registry.progress[val] % lerp_registry.render_interval[val] \n                if (allow_render == 0) {\n                    lerp_registry.delta_t[val] = lerp_registry.progress[val] / lerp_registry.duration[val];\n                    switch(lerp_registry.type[val]){\n                        case(2):\n                        lerp_registry.results.set(val, smoothLerp(\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]],\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]+1],\n                                lerp_registry.delta_t[val] ,\n                                lerp_registry.smoothstep[val]\n                            ))\n                            break\n                        case(3):\n                             for (let i=0;i< lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]).length;i++)\n                            {\n                                lerp_registry.results.get(val)[i]= smoothLerp(\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val])[i],\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]+1)[i],\n                                    lerp_registry.delta_t[val] ,\n                                    lerp_registry.smoothstep[val]\n                                )\n                            }\n                            break;\n                        default:\n                            break\n                    }\n                   args={id:val,value:lerp_registry.results.get(val),step:lerpChain_registry.progress[val], time:lerp_registry.progress[val] ,step:lerpChain_registry.progress[val]} //time war vorther lerp_registry.delta_t[val]\n                   if(lerp_registry.lerp_callbacks.has(val)) {\n                     lerp_registry.lerp_callbacks.get(val)(args)\n                   }\n                }\n                lerp_registry.progress[val] += 1\n                if (allow_render==0) {\n                    triggers_step=trigger_registry.get(val)!=undefined?trigger_registry.get(val).get(lerpChain_registry.progress[val]):undefined\n                    if ( triggers_step != undefined) {\n                        targets= triggers_step.get(lerp_registry.progress[val]-1)\n                        targets&&targets.map((target)=>{\n                            lerpChain_registry.soft_reset(target)\n                        })\n                    }\n                }\n            }\n        } \n        else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n                finished.push(val);\n            }\n        }\n    })\n    return finished\n}\nvar startTime,timeoutId\nasync function animateLoop() {\n      loop_resolver = new AbortController()\n      loop_resolver.signal.addEventListener('abort', () => {\n        clearTimeout(timeoutId);\n      });\n      while (loop_resolver.signal.aborted == false) {\n        startTime = performance.now();\n        finished = [];\n        if (lerp_registry.activelist.length > 0) {\n          animate()\n          render();\n          if (finished.length > 0) {\n            lerp_registry.activelist = lerp_registry.activelist.filter((active) => !finished.includes(active));\n          }\n          if (lerp_registry.activelist[\"length\"] > 0) {\n            await new Promise((resolve,reject) => {\n              timeoutId = setTimeout(() => {\n                resolve();\n              }, Math.max(0, fps - (performance.now() - startTime)));\n              \n            });\n          }\n        else {\n           return stop_loop()\n           \n          }\n        }\n      }\n  }\n\nfunction start_loop() {\n    if(loop_resolver==null){\n            animateLoop()\n    }    \n}\nasync function stop_loop() {\n    if(loop_resolver!=null){\n        loop_resolver.abort()\n        loop_resolver=null\n    }\n}\n    /**\n     * starts a list of animations\n     * @param {Array<number>} indices an array of ids of the animations to start\n     */\nfunction start_animations(indices){\n    indices.map((id)=>{\n        lerpChain_registry.soft_reset(id)\n    })\n    start_loop()\n}\n    /**\n     * stops a list of animations\n     * @param {Array<number>|string} indices an array of ids of the animations to stop; if \"all\", stops all animations\n     */\nfunction stop_animations(indices){\n    if(indices===\"all\"){\n        lerp_registry.activelist=[]\n        stop_loop()\n    }\n    else{\n        indices.map((id)=>{\n            if(lerp_registry.activelist.includes(id)){\n                lerp_registry.activelist=lerp_registry.activelist.filter((x)=>x!=id)\n            }\n        })\n    }\n    if (lerp_registry.activelist.length == 0) {\n        stop_loop()\n    } \n}\n/**\n * Resets a list of animations.\n * \n * If \"all\" is passed, stops the animation loop and resets all active animations.\n * Otherwise, resets each animation in the provided indices, re-activates it, and \n * updates the results based on its type. If any animations were stopped and reset,\n * a render message is posted with the updated results.\n * \n * @param {Array<number>|string} indices - An array of animation IDs to reset, or \"all\" to reset all animations.\n */\n\nasync function reset_animations(indices){\n    if(indices==\"all\"){stop_loop();indices=lerp_registry.activelist}\n    //stop_animations(indices)\n    const stopped=[]    \n    indices.map((x)=>{\n        lerpChain_registry.reset(x);\n        lerp_registry.activate(x)\n        if(lerp_registry.activelist.includes(x)==false || loop_resolver==null){\n            stopped.push(x)\n            switch(lerp_registry.type[x]){\n                case(2):\n                    lerp_registry.results.set(x,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x]])\n                    break\n                case(3):\n                    lerp_registry.results.set(x,lerpChain_registry.matrixChains.get(x).get(0))\n                    break\n                default:break;\n        }\n    }\n    })\n    if(stopped.length>0) postMessage({ message: \"render\", results: lerp_registry.results, result_indices: indices })\n}\n/**\n * Changes the framerate of the animation loop.\n * \n * @param {number} fps_new - The new framerate in frames per second.\n */\nfunction change_framerate(fps_new) {\n     fps = fps_new \n    }\nconst integers = [\"loop\",\"delay\",\"type\",\"progress\",\"duration\",\"render_interval\",\"lerp_chain_start\",\"activelist\"]\nfunction init(new_fps, lerps, lerpChains, matrixChains, triggers, constants, condi_new, lerp_callbacks, springs) {\n    fps=new_fps\n    triggers.forEach((trigger,key)=>trigger_registry.set(key,trigger))\n    condi_new.forEach((val,key)=>{\n            callback_map.set(key,eval(val))\n    })\n    lerp_callbacks.forEach((val,key)=>{\n            // no shallow copy just copying the pointer\n            lerp_registry.lerp_callbacks.set(key,callback_map.get(val))\n    })\n    \n    lerpChains.forEach((arr,name)=>{\n            lerpChain_registry[name]=new Float32Array(arr)\n          //  console.log(lerpChain_registry[name])\n    })\n    lerpChain_registry.matrixChains=matrixChains\n    lerps.forEach((array, name) => {\n            if(integers.includes(name)==false ){\n                lerp_registry[name] = new Float32Array(array)\n            }\n            else{lerp_registry[name] = new Uint8Array(array)}\n    })\n    if(constants.get(\"matrix\")!=undefined){\n        constants.get(\"matrix\").forEach((val,i)=>{\n            constant_registry.matrix.set(i,new Map())\n            val.map((m,i2)=>{constant_registry.matrix.get(i).set(i2,new Float32Array(m))})\n        })\n    }\n    if(constants.get(\"number\")!=undefined){\n        constant_registry.number=constants.get(\"number\")\n    }\n    constant_registry.render_triggers=constants.get(\"render_triggers\")\n    constant_registry.render_callbacks=constants.get(\"render_callbacks\")\n    lerp_registry.type.map((t,i)=>{\n        //  TODO hier zur vereinfachung interne get funktionen nehmen\n        if(t==2){\n            lerp_registry.results.set(i,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[i]])\n        }\n        else if(t==3){\n            lerp_registry.results.set(i,new Float32Array(lerpChain_registry.matrixChains.get(i).get(0)))\n        }\n    })\n    lerp_registry.delta_t=new Float32Array(lerp_registry.duration.length)\n    lerp_registry.delay_delta=new Float32Array(lerp_registry.duration.length)\n}\n/**\n * Adds a trigger to the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, it is created.\n * If the trigger does exist, the target is added to the existing trigger.\n * @param {number} id - The id of the animation to add the trigger to.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\nfunction addTrigger(id,target,step,time){\n    var trigger = []\n    if(trigger_registry.get(id)==undefined){\n        trigger_registry.set(id,new Map())\n    }\n    if(trigger_registry.get(id).get(step)==undefined){\n        trigger_registry.get(id).set(step, new Map())\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else if(trigger_registry.get(id).get(step).get(time)==undefined){\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else{\n        trigger=trigger_registry.get(id).get(step).get(time)\n        if(trigger.includes(target)==false){\n            var newtriggers=new Array(trigger)\n            newtriggers.push(target)\n            newtriggers= new Uint8Array(newtriggers)\n            trigger_registry.get(id).get(step).set(time,newtriggers)\n        }\n        else{\n            console.warn(`trigger already exists: target ${target} in timeframe ${time} in step ${step} on animation with id ${id}`)\n        }   \n    }\n}\n/**\n * Removes a trigger from the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, a warning is printed.\n * If the trigger does exist, the target is removed from the existing trigger.\n * If the trigger is empty after removal (i.e. it only contained the target), the trigger is removed.\n * @param {number} id - The id of the animation to remove the trigger from.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\nfunction removeTrigger(id,target,step,time){\n    var trigger=trigger_registry.get(id).get(step)\n    if(trigger!=undefined){\n        if(trigger.get(time)!=undefined){\n            trigger=trigger.get(time)\n        }\n        else{\n            return(console.warn(\"the slected timeframe in the  step does not include the target\"))\n        }\n    }\n    else{\n        return(console.warn(\"the trigger registr has does not include the step\"))\n    }\n    const targetId=trigger.indexOf(target)\n    if(targetId!=undefined&&trigger.length>1){\n        const newtriggers= new Uint8Array(new Array(trigger).splice(targetId,1))\n        console.log(`removed trigger target ${target} in timeframe ${time} in step ${step} from from id ${id}`)\n        trigger_registry.get(id).get(step).set(time,newtriggers)\n    }\n    else {\n        trigger_registry.get(id).get(step).set(time,undefined)\n    }\n    // else{\n    //     trigger_registry.get(id).set(step,undefined)\n    // }\n}\nfunction update(type,values){\n    values.map((x)=>{\n        if(lerpChain_registry.lengths[x.id]!=x.values.length-1){\n            console.log(trigger_registry.get(x.id))\n            if(lerp_registry.loop[x.id]==1){\n            removeTrigger(x.id,x.id,lerpChain_registry.lengths[x.id]-1,lerp_registry.duration[x.id])\n            addTrigger(x.id,x.id,x.values.length-2,lerp_registry.duration[x.id])\n            //trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n        }\n        lerpChain_registry.lengths[x.id]=x.values.length-1\n        }\n        if(type==2){\n            x.values.map((val,i)=>{\n                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x.id]+i]=val\n            })\n        }\n        else if(type==3){\n            x.values.map((val,i)=>{\n                lerpChain_registry.matrixChains.get(x.id).set(i,val)\n            })\n        }\n        lerpChain_registry.reset(x.id)\n    })\n}\n\n/**\n * Calls a lambda function stored in callback_map with the given id and arguments.\n * @param {number} id - The id of the lambda function to call\n * @param {any[]} args - The arguments to pass to the lambda function\n */\nfunction lambda_call(id,args){\n       callback_map.get(id)(args)\n}\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    const active=lerp_registry.activelist.filter((x)=>lerp_registry.type[x]!=4)\n    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: active }) \n}\n/**\n * This function can be called by the worker when a constant value is changed.\n * The main thread will receive a message with the changed value.\n * @param {number} id - the id of the constant\n * @param {number} type - the type of the constant (0 = number, 1 = matrix)\n */\nasync function render_constant(id,type) {\n    postMessage({ message: \"render_constant\", id:id, type: type, value:  get_constant(id,type)})\n}\nvar const_map_new\nonmessage = (event) => {\n    switch (event.data.method) {\n        case 'init':\n            init(\n                event.data.fps,\n                event.data.data, \n                event.data.chain_map, \n                event.data.matrix_chain_map, \n                event.data.trigger_map, \n                event.data.constants, \n                event.data.callback_map, \n                event.data.lerp_callbacks, \n                event.data.spring_map\n            );\n            break;\n        case \"update\":\n            update(event.data.type,event.data.data)\n            break\n        case 'update_constant':\n                if(event.data.type==\"matrix\"){\n                    const_map_new=new Map\n                event.data.value.map((val,i)=>{\n                    if(typeof(val)!=\"function\"){\n                        event.data.value[i]=new Float32Array(val)\n                    }        \n                    const_map_new.set(i,event.data.value[i])\n                })\n                constant_registry.update(event.data.type, event.data.id,const_map_new);\n            }\n            else{\n                constant_registry.update(event.data.type, event.data.id,event.data.value);\n            }\n            \n            break;\n        case 'start':\n            start_loop();\n            break;\n        case 'set_lambda':\n             callback_map.set(event.data.id,eval(event.data.callback))\n            break;\n        //makes no sense since we would require a promise on the mainthread\n        //this is shitty, cause you have to have a list of promises\n        //however the user can still use get_active on the worker via callbacks, or lambdas\n        // case 'get_active':\n        //     postMessage({ message: \"get_active\", active:lerp_registry.activelist})\n        //     break;\n        case 'stop':\n            stop_loop()\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'lambda_call':\n            lambda_call(event.data.id,event.data.args);\n            break;\n        case 'start_animations':\n            start_animations(event.data.indices);\n            break;\n        case 'stop_animations':\n                stop_animations(event.data.indices);\n            break;\n        case 'reset_animations':\n            reset_animations(event.data.indices);\n            break;\n        case 'addTrigger':\n            addTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        case 'removeTrigger':\n            removeTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        default:\n            console.warn(\"no method selected during worker call\")\n            break\n    }\n};\n// ----------------------------------------> User API <--\n\n/**\n * Sets a Lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number} value - the value to set\n */\nfunction setLerp(index,step,value){\n    //console.log(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step])\n    lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step]=value\n}\n/**\n * Sets the matrix lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number[]} value - the matrix to set. The matrix is a 1 dimensional array of floats with a length that is a multiple of 4 (e.g. [r1, g1, b1, a1, r2, g2, b2, a2])\n */\nfunction setMatrix(index,step,value){\n   // console.log(lerpChain_registry.matrixChains.get(index).get(step))\n    value.map((x,i) => {\n        lerpChain_registry.matrixChains.get(index).get(step)[i]=x\n    })\n   // lerpChain_registry.matrixChains.get(index).get(step)\n}\n/**\n * Updates a constant value.\n * @param {number} id - the id of the constant to update\n * @param {string} type - the type of the constant (number or matrix)\n * @param {number | number[]} value - the new value of the constant\n */\nfunction update_constant(id,type,value){constant_registry.update(type,id,value)}\n/**\n * Gets a constant value.\n * @param {number} id - the id of the constant\n * @param {string} type - the type of the constant (number or matrix)\n * @returns {number | number[]} value - the value of the constant\n */\nfunction get_constant(id,type){return constant_registry.get(type,id)}\n/**\n * Gets the current progress of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current progress value of the animation.\n */\nfunction get_time(id){return lerp_registry.progress[id]}\n/**\n * Checks if an animation is currently running.\n * @param {number} id - The identifier for the animation.\n * @returns {boolean} - true if the animation is currently running, false otherwise.\n */\nfunction is_active(id){return lerp_registry.activelist.includes(id)}\n/**\n * Gets the current step of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current step value of the animation.\n */\nfunction get_step(id){return lerpChain_registry.progress(id)}\n/**\n * Gets the lerp result value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The lerp result value of the animation.\n */\nfunction get_lerp_value(id){return lerp_registry.results.get(id)}\n/**\n * Starts and resets an animation if its finished, or not playing.\n * @param {number} id - The identifier for the animation.\n */\nfunction soft_reset(id){lerpChain_registry.soft_reset(id)}\n/**\n * Starts and resets an animation.\n * @param {number} id - The identifier for the animation.\n */\nfunction hard_reset(id){lerpChain_registry.reset(id)}\n/**\n * Sets the current progress of an animation and updates the delta t value accordingly.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The new progress value for the animation.\n */\nfunction set_delta_t(id,val){lerp_registry.progress=val;lerp_registry.delta_t[id]=lerp_registry.duration[id]/lerp_registry.progress[id]}\n/**\n * Sets the current step of an animation.\n * If the provided step value exceeds the maximum length of the animation, it will be set to the maximum length.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired step value for the animation.\n */\n\nfunction set_step(id,val){lerpChain_registry.progress[id]=val>lerpChain_registry.lengths[id]?lerpChain_registry.lengths[id]:val}\n/**\n * Gets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The duration of the animation.\n */\nfunction get_duration(id){return lerp_registry.duration[id]}\n/**\n * Sets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired duration value for the animation.\n */\nfunction set_duration(id,val){lerp_registry.duration[id]=val}\n/**\n * Retrieves the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The delay value of the animation.\n */\n\nfunction get_delay(id){return lerp_registry.delay[id]}\n/**\n * Sets the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay value for the animation.\n */\nfunction set_delay(id,val){\n    lerp_registry.delay[id]=val\n}\n\n\n/**\n * Retrieves the current delay progress value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current delay progress value of the animation.\n */\nfunction get_delay_delta(id){\n    return lerp_registry.delay_delta[id]}\n/**\n * Sets the current delay progress value for an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay progress value for the animation.\n */\nfunction set_delay_delta(id,val){lerp_registry.delay_delta[id]=val}\n/**\n * Sets the sequence length of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired sequence length for the animation.\n */\nfunction set_sequence_length(id,val){lerpChain_registry.lengths[id]=val}\n/**\n * Retrieves a specific row from a matrix constant.\n * @param {number} id - The identifier for the matrix constant.\n * @param {number} row - The index of the row to retrieve from the matrix constant.\n * @returns {Array} - The specified row from the matrix constant.\n */\nfunction get_constant_row(id,row){return constant_registry.get_row(id,row)}\n\n/**\n * Retrieves a constant number value by its identifier.\n * @param {number} id - The identifier for the constant number.\n * @returns {number} - The constant number value associated with the given identifier.\n */\nfunction get_constant_number(id){\n    return constant_registry.get_number(id)}\n/**\n * Retrieves an array of all active animation identifiers.\n * @returns {Array<number>} - An array of active animation identifiers.\n */\nfunction get_active(id){return lerp_registry.activelis}\n/**\n * Retrieves a boolean indicating whether the animation loop is currently running.\n * @returns {boolean} - true if the animation loop is currently running, false otherwise.\n */\nfunction get_status(){\n    return loop_resolver!=null\n}\n\n\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n// this has to commented out when creating the docs\nexport {\n    get_status,\n    addTrigger,removeTrigger,\n    get_time,set_delta_t,\n    get_step,set_step,\n    is_active,get_active,\n    start_animations,stop_animations,\n    setLerp,setMatrix,\n    get_lerp_value,\n    soft_reset,hard_reset,\n    get_duration,set_duration,\n    set_sequence_length,\n    change_framerate,\n    get_constant,get_constant_number,get_constant_row,render_constant,\n    update_constant,\n    set_delay,get_delay,\n    get_delay_delta,set_delay_delta,\n    lambda_call,\n}\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n// const eslapsed = performance.now() - startTime;\n// const waitTime = Math.max(0, fps - elapsed);\n// postMessage({\n//     message: \"finish\",\n//     results: lerp_registry.results,\n//     result_indices: lerp_registry.activelist\n// });\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n// }\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","signal","loop_resolver","triggers_step","callback_map","Map","Lerp","constructor","this","type","undefined","delta_t","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","loop","activelist","results","lerp_callbacks","activate","id","includes","push","index","final_step","final_sub_step","LerpChain","buffer","matrixChains","lengths","update_progress","reset_and_update","lerp_registry","reset","set","lerpChain_registry","soft_reset","Constant","matrices","numbers","matrix","number","render_triggers","render_callbacks","update","value","constant_registry","has","map","l","args","start_animations","row","get_row","get_number","trigger_registry","t","targets","allow_render","startTime","timeoutId","smoothLerp","min","max","v","amount","x","async","animate","val","i","length","step","time","target","animateLoop","AbortController","addEventListener","clearTimeout","aborted","performance","now","render","filter","active","stop_loop","Promise","resolve","reject","setTimeout","Math","start_loop","abort","indices","stop_animations","reset_animations","stopped","postMessage","message","result_indices","change_framerate","fps_new","integers","init","new_fps","lerps","lerpChains","triggers","constants","condi_new","springs","forEach","trigger","eval","arr","name","Float32Array","array","Uint8Array","m","i2","addTrigger","newtriggers","Array","console","warn","concat","removeTrigger","targetId","indexOf","splice","log","values","lambda_call","render_constant","get_constant","const_map_new","setLerp","setMatrix","update_constant","get_time","is_active","get_step","get_lerp_value","hard_reset","set_delta_t","set_step","get_duration","set_duration","get_delay","set_delay","get_delay_delta","set_delay_delta","set_sequence_length","get_constant_row","get_constant_number","get_active","activelis","get_status","onmessage","event","data","method","chain_map","matrix_chain_map","trigger_map","spring_map","callback","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}