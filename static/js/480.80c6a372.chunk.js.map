{"version":3,"file":"static/js/480.80c6a372.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../../../kooljs/kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n\n// 1. All commercial uses of the Software must:  \n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).  \n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).  \n\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  \nvar finished = []\nvar fps = 10.33\nvar signal,loop_resolver = null\nvar triggers_step\nconst callback_map=new Map()\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.type = undefined\n        this.delta_t = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.loop=undefined\n        this.activelist = []\n        this.results = new Map()\n        this.lerp_callbacks=new Map()\n    }\n    activate(id) {\n        if (this.activelist.includes(id) == false) {\n            this.activelist.push(id)\n            return true\n        }\n        return false\n    }\n    get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.results.get(index)\n    }\n}\nvar final_step,final_sub_step\n\nclass LerpChain{\n/**\n * The constructor for the LerpChain class.\n * Initializes properties related to the state and progress of the lerp chain.\n * \n * @property {Array|undefined} buffer - The buffer holding the chain data.\n * @property {Map|undefined} matrixChains - The map containing matrix chains.\n * @property {Array|undefined} progress - The progress of each chain.\n * @property {Array|undefined} lengths - The lengths of each chain.\n */\n\n    constructor(){\n        this.buffer=undefined\n        this.matrixChains=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        if(this.progress[id]==this.lengths[id]-1){\n            return true\n        }\n        else{\n            this.reset_and_update(id)\n            return(false)\n        }\n    }\n    reset_and_update(id){\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0\n        this.progress[id]+=1\n    }\n    reset(id){\n        if(lerp_registry.type[id]==2){\n            lerp_registry.results.set(id,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[id]])\n        }\n        else if(lerp_registry.type[id]==3){\n            lerp_registry.results.set(id,lerpChain_registry.matrixChains.get(id).get(0))\n        }\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0   \n        this.progress[id]=0\n    }\n    soft_reset(id){\n        final_step=this.progress[id]==this.lengths[id]-1\n        final_sub_step=lerp_registry.progress[id]>=lerp_registry.duration[id]\n        lerp_registry.activate(id)\n        if(final_step && final_sub_step){\n            this.reset(id)\n        }\n        else if(final_sub_step){\n            this.reset_and_update(id)\n        }\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=new Map()\n        this.number=undefined\n        this.render_triggers=new Map()\n        this.render_callbacks=new Map()\n    }\n   update(type, id, value){\n        constant_registry[type].set(id,value)\n        if(this.render_callbacks.has(id))  this.render_callbacks.get(id).map((l) => {\n            console.log(l)\n            callback_map.get(l.id)(l.args)\n        })\n        if(this.render_triggers.has(id)) start_animations(this.render_triggers.get(id))\n     }\n    get(type,index,row){\n        if(row!=undefined){\n            this.get_row(index,row)\n        }\n        else return constant_registry[type].get(index)\n    }\n    get_row(index,row){\n        return constant_registry[\"matrix\"].get(index).get(row)\n    }\n    get_number(index){\n        return constant_registry[\"number\"].get(index)\n    }\n}\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst lerpChain_registry = new LerpChain()\nconst trigger_registry = new Map()\n// ----------------------------------------> ANIMATION <--\nvar t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\n//var triggers,triggers_step\nvar targets,allow_render, args\nasync function animate() {\n    finished=[]\n    lerp_registry.activelist.map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] <= lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                allow_render=lerp_registry.progress[val] % lerp_registry.render_interval[val] \n                if (allow_render == 0) {\n                    lerp_registry.delta_t[val] = lerp_registry.progress[val] / lerp_registry.duration[val];\n                    switch(lerp_registry.type[val]){\n                        case(2):\n                        lerp_registry.results.set(val, smoothLerp(\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]],\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]+1],\n                                lerp_registry.delta_t[val] ,\n                                lerp_registry.smoothstep[val]\n                            ))\n                            break\n                        case(3):\n                             for (let i=0;i< lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]).length;i++)\n                            {\n                                lerp_registry.results.get(val)[i]= smoothLerp(\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val])[i],\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]+1)[i],\n                                    lerp_registry.delta_t[val] ,\n                                    lerp_registry.smoothstep[val]\n                                )\n                            }\n                            break;\n                        default:\n                            break\n                    }\n                   args={id:val,value:lerp_registry.results.get(val),step:lerpChain_registry.progress[val], time:lerp_registry.progress[val] ,step:lerpChain_registry.progress[val]} //time war vorther lerp_registry.delta_t[val]\n                   if(lerp_registry.lerp_callbacks.has(val)) {\n                     lerp_registry.lerp_callbacks.get(val)(args)\n                   }\n                }\n                lerp_registry.progress[val] += 1\n                if (allow_render==0) {\n                    triggers_step=trigger_registry.get(val)!=undefined?trigger_registry.get(val).get(lerpChain_registry.progress[val]):undefined\n                    if ( triggers_step != undefined) {\n                        targets= triggers_step.get(lerp_registry.progress[val]-1)\n                        targets&&targets.map((target)=>{\n                            lerpChain_registry.soft_reset(target)\n                        })\n                    }\n                }\n            }\n        } \n        else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n                finished.push(val);\n            }\n        }\n    })\n    return finished\n}\nvar startTime,timeoutId\nasync function animateLoop() {\n      loop_resolver = new AbortController()\n      loop_resolver.signal.addEventListener('abort', () => {\n        clearTimeout(timeoutId);\n      });\n      while (loop_resolver.signal.aborted == false) {\n        startTime = performance.now();\n        finished = [];\n        if (lerp_registry.activelist.length > 0) {\n          animate()\n          render();\n          if (finished.length > 0) {\n            lerp_registry.activelist = lerp_registry.activelist.filter((active) => !finished.includes(active));\n          }\n          if (lerp_registry.activelist[\"length\"] > 0) {\n            await new Promise((resolve,reject) => {\n              timeoutId = setTimeout(() => {\n                resolve();\n              }, Math.max(0, fps - (performance.now() - startTime)));\n              \n            });\n          }\n        else {\n           return stop_loop()\n           \n          }\n        }\n      }\n  }\n\nfunction start_loop() {\n    if(loop_resolver==null){\n            animateLoop()\n    }    \n}\nasync function stop_loop() {\n    if(loop_resolver!=null){\n        loop_resolver.abort()\n        loop_resolver=null\n    }\n}\n    /**\n     * starts a list of animations\n     * @param {Array<number>} indices an array of ids of the animations to start\n     */\nfunction start_animations(indices){\n    indices.map((id)=>{\n        lerpChain_registry.soft_reset(id)\n    })\n    start_loop()\n}\n    /**\n     * stops a list of animations\n     * @param {Array<number>|string} indices an array of ids of the animations to stop; if \"all\", stops all animations\n     */\nfunction stop_animations(indices){\n    if(indices===\"all\"){\n        lerp_registry.activelist=[]\n        stop_loop()\n    }\n    else{\n        indices.map((id)=>{\n            if(lerp_registry.activelist.includes(id)){\n                lerp_registry.activelist=lerp_registry.activelist.filter((x)=>x!=id)\n            }\n        })\n    }\n    if (lerp_registry.activelist.length == 0) {\n        stop_loop()\n    } \n}\n/**\n * Resets a list of animations.\n * \n * If \"all\" is passed, stops the animation loop and resets all active animations.\n * Otherwise, resets each animation in the provided indices, re-activates it, and \n * updates the results based on its type. If any animations were stopped and reset,\n * a render message is posted with the updated results.\n * \n * @param {Array<number>|string} indices - An array of animation IDs to reset, or \"all\" to reset all animations.\n */\n\nasync function reset_animations(indices){\n    if(indices==\"all\"){stop_loop();indices=lerp_registry.activelist}\n    //stop_animations(indices)\n    const stopped=[]    \n    indices.map((x)=>{\n        lerpChain_registry.reset(x);\n        lerp_registry.activate(x)\n        if(lerp_registry.activelist.includes(x)==false || loop_resolver==null){\n            stopped.push(x)\n            switch(lerp_registry.type[x]){\n                case(2):\n                    lerp_registry.results.set(x,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x]])\n                    break\n                case(3):\n                    lerp_registry.results.set(x,lerpChain_registry.matrixChains.get(x).get(0))\n                    break\n                default:break;\n        }\n    }\n    })\n    if(stopped.length>0) postMessage({ message: \"render\", results: lerp_registry.results, result_indices: indices })\n}\n/**\n * Changes the framerate of the animation loop.\n * \n * @param {number} fps_new - The new framerate in frames per second.\n */\nfunction change_framerate(fps_new) {\n     fps = fps_new \n    }\nconst integers = [\"loop\",\"delay\",\"type\",\"progress\",\"duration\",\"render_interval\",\"lerp_chain_start\",\"activelist\"]\nfunction init(new_fps, lerps, lerpChains, matrixChains, triggers, constants, condi_new, lerp_callbacks, springs) {\n    fps=new_fps\n    triggers.forEach((trigger,key)=>trigger_registry.set(key,trigger))\n    condi_new.forEach((val,key)=>{\n            callback_map.set(key,eval(val))\n    })\n    lerp_callbacks.forEach((val,key)=>{\n            // no shallow copy just copying the pointer\n            lerp_registry.lerp_callbacks.set(key,callback_map.get(val))\n    })\n    \n    lerpChains.forEach((arr,name)=>{\n            lerpChain_registry[name]=new Float32Array(arr)\n          //  console.log(lerpChain_registry[name])\n    })\n    lerpChain_registry.matrixChains=matrixChains\n    lerps.forEach((array, name) => {\n            if(integers.includes(name)==false ){\n                lerp_registry[name] = new Float32Array(array)\n            }\n            else{lerp_registry[name] = new Uint8Array(array)}\n    })\n    if(constants.get(\"matrix\")!=undefined){\n        constants.get(\"matrix\").forEach((val,i)=>{\n            constant_registry.matrix.set(i,new Map())\n            val.map((m,i2)=>{constant_registry.matrix.get(i).set(i2,new Float32Array(m))})\n        })\n    }\n    if(constants.get(\"number\")!=undefined){\n        constant_registry.number=constants.get(\"number\")\n    }\n    constant_registry.render_triggers=constants.get(\"render_triggers\")\n    constant_registry.render_callbacks=constants.get(\"render_callbacks\")\n    lerp_registry.type.map((t,i)=>{\n        //  TODO hier zur vereinfachung interne get funktionen nehmen\n        if(t==2){\n            lerp_registry.results.set(i,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[i]])\n        }\n        else if(t==3){\n            lerp_registry.results.set(i,new Float32Array(lerpChain_registry.matrixChains.get(i).get(0)))\n        }\n    })\n    lerp_registry.delta_t=new Float32Array(lerp_registry.duration.length)\n    lerp_registry.delay_delta=new Float32Array(lerp_registry.duration.length)\n}\n/**\n * Adds a trigger to the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, it is created.\n * If the trigger does exist, the target is added to the existing trigger.\n * @param {number} id - The id of the animation to add the trigger to.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\nfunction addTrigger(id,target,step,time){\n    var trigger = []\n    if(trigger_registry.get(id)==undefined){\n        trigger_registry.set(id,new Map())\n    }\n    if(trigger_registry.get(id).get(step)==undefined){\n        trigger_registry.get(id).set(step, new Map())\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else if(trigger_registry.get(id).get(step).get(time)==undefined){\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else{\n        trigger=trigger_registry.get(id).get(step).get(time)\n        if(trigger.includes(target)==false){\n            var newtriggers=new Array(trigger)\n            newtriggers.push(target)\n            newtriggers= new Uint8Array(newtriggers)\n            trigger_registry.get(id).get(step).set(time,newtriggers)\n        }\n        else{\n            console.warn(`trigger already exists: target ${target} in timeframe ${time} in step ${step} on animation with id ${id}`)\n        }   \n    }\n}\n/**\n * Removes a trigger from the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, a warning is printed.\n * If the trigger does exist, the target is removed from the existing trigger.\n * If the trigger is empty after removal (i.e. it only contained the target), the trigger is removed.\n * @param {number} id - The id of the animation to remove the trigger from.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\nfunction removeTrigger(id,target,step,time){\n    var trigger=trigger_registry.get(id).get(step)\n    if(trigger!=undefined){\n        if(trigger.get(time)!=undefined){\n            trigger=trigger.get(time)\n        }\n        else{\n            return(console.warn(\"the slected timeframe in the  step does not include the target\"))\n        }\n    }\n    else{\n        return(console.warn(\"the trigger registr has does not include the step\"))\n    }\n    const targetId=trigger.indexOf(target)\n    if(targetId!=undefined&&trigger.length>1){\n        const newtriggers= new Uint8Array(new Array(trigger).splice(targetId,1))\n        console.log(`removed trigger target ${target} in timeframe ${time} in step ${step} from from id ${id}`)\n        trigger_registry.get(id).get(step).set(time,newtriggers)\n    }\n    else {\n        trigger_registry.get(id).get(step).set(time,undefined)\n    }\n    // else{\n    //     trigger_registry.get(id).set(step,undefined)\n    // }\n}\nfunction update(type,values){\n    values.map((x)=>{\n        if(lerpChain_registry.lengths[x.id]!=x.values.length-1){\n            console.log(trigger_registry.get(x.id))\n            if(lerp_registry.loop[x.id]==1){\n            removeTrigger(x.id,x.id,lerpChain_registry.lengths[x.id]-1,lerp_registry.duration[x.id])\n            addTrigger(x.id,x.id,x.values.length-2,lerp_registry.duration[x.id])\n            //trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n        }\n        lerpChain_registry.lengths[x.id]=x.values.length-1\n        }\n        if(type==2){\n            x.values.map((val,i)=>{\n                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x.id]+i]=val\n            })\n        }\n        else if(type==3){\n            x.values.map((val,i)=>{\n                lerpChain_registry.matrixChains.get(x.id).set(i,val)\n            })\n        }\n        lerpChain_registry.reset(x.id)\n    })\n}\n\n/**\n * Calls a lambda function stored in callback_map with the given id and arguments.\n * @param {number} id - The id of the lambda function to call\n * @param {any[]} args - The arguments to pass to the lambda function\n */\nfunction lambda_call(id,args){\n       callback_map.get(id)(args)\n}\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    const active=lerp_registry.activelist.filter((x)=>lerp_registry.type[x]!=4)\n    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: active }) \n}\n/**\n * This function can be called by the worker when a constant value is changed.\n * The main thread will receive a message with the changed value.\n * @param {number} id - the id of the constant\n * @param {number} type - the type of the constant (0 = number, 1 = matrix)\n */\nasync function render_constant(id,type) {\n    postMessage({ message: \"render_constant\", id:id, type: type, value:  get_constant(id,type)})\n}\nonmessage = (event) => {\n    switch (event.data.method) {\n        case 'init':\n            init(\n                event.data.fps,\n                event.data.data, \n                event.data.chain_map, \n                event.data.matrix_chain_map, \n                event.data.trigger_map, \n                event.data.constants, \n                event.data.callback_map, \n                event.data.lerp_callbacks, \n                event.data.spring_map\n            );\n            break;\n        case \"update\":\n            update(event.data.type,event.data.data)\n            break\n        case 'update_constant':\n            constant_registry.update(event.data.type, event.data.id,event.data.value);\n            break;\n        case 'start':\n            start_loop();\n            break;\n        case 'set_lambda':\n             callback_map.set(event.data.id,eval(event.data.callback))\n            break;\n        //makes no sense since we would require a promise on the mainthread\n        //this is shitty, cause you have to have a list of promises\n        //however the user can still use get_active on the worker via callbacks, or lambdas\n        // case 'get_active':\n        //     postMessage({ message: \"get_active\", active:lerp_registry.activelist})\n        //     break;\n        case 'stop':\n            stop_loop()\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'lambda_call':\n            lambda_call(event.data.id,event.data.args);\n            break;\n        case 'start_animations':\n            start_animations(event.data.indices);\n            break;\n        case 'stop_animations':\n                stop_animations(event.data.indices);\n            break;\n        case 'reset_animations':\n            reset_animations(event.data.indices);\n            break;\n        case 'addTrigger':\n            addTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        case 'removeTrigger':\n            removeTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        default:\n            console.warn(\"no method selected during worker call\")\n            break\n    }\n};\n// ----------------------------------------> User API <--\n\n/**\n * Sets a Lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number} value - the value to set\n */\nfunction setLerp(index,step,value){\n    //console.log(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step])\n    lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step]=value\n}\n/**\n * Sets the matrix lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number[]} value - the matrix to set. The matrix is a 1 dimensional array of floats with a length that is a multiple of 4 (e.g. [r1, g1, b1, a1, r2, g2, b2, a2])\n */\nfunction setMatrix(index,step,value){\n   // console.log(lerpChain_registry.matrixChains.get(index).get(step))\n    value.map((x,i) => {\n        lerpChain_registry.matrixChains.get(index).get(step)[i]=x\n    })\n   // lerpChain_registry.matrixChains.get(index).get(step)\n}\n/**\n * Updates a constant value.\n * @param {number} id - the id of the constant to update\n * @param {string} type - the type of the constant (number or matrix)\n * @param {number | number[]} value - the new value of the constant\n */\nfunction update_constant(id,type,value){constant_registry.update(type,id,value)}\n/**\n * Gets a constant value.\n * @param {number} id - the id of the constant\n * @param {string} type - the type of the constant (number or matrix)\n * @returns {number | number[]} value - the value of the constant\n */\nfunction get_constant(id,type){return constant_registry.get(type,id)}\n/**\n * Gets the current progress of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current progress value of the animation.\n */\nfunction get_time(id){return lerp_registry.progress[id]}\n/**\n * Checks if an animation is currently running.\n * @param {number} id - The identifier for the animation.\n * @returns {boolean} - true if the animation is currently running, false otherwise.\n */\nfunction is_active(id){return lerp_registry.activelist.includes(id)}\n/**\n * Gets the current step of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current step value of the animation.\n */\nfunction get_step(id){return lerpChain_registry.progress(id)}\n/**\n * Gets the lerp result value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The lerp result value of the animation.\n */\nfunction get_lerp_value(id){return lerp_registry.results.get(id)}\n/**\n * Starts and resets an animation if its finished, or not playing.\n * @param {number} id - The identifier for the animation.\n */\nfunction soft_reset(id){lerpChain_registry.soft_reset(id)}\n/**\n * Starts and resets an animation.\n * @param {number} id - The identifier for the animation.\n */\nfunction hard_reset(id){lerpChain_registry.reset(id)}\n/**\n * Sets the current progress of an animation and updates the delta t value accordingly.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The new progress value for the animation.\n */\nfunction set_delta_t(id,val){lerp_registry.progress=val;lerp_registry.delta_t[id]=lerp_registry.duration[id]/lerp_registry.progress[id]}\n/**\n * Sets the current step of an animation.\n * If the provided step value exceeds the maximum length of the animation, it will be set to the maximum length.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired step value for the animation.\n */\n\nfunction set_step(id,val){lerpChain_registry.progress[id]=val>lerpChain_registry.lengths[id]?lerpChain_registry.lengths[id]:val}\n/**\n * Gets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The duration of the animation.\n */\nfunction get_duration(id){return lerp_registry.duration[id]}\n/**\n * Sets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired duration value for the animation.\n */\nfunction set_duration(id,val){lerp_registry.duration[id]=val}\n/**\n * Retrieves the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The delay value of the animation.\n */\n\nfunction get_delay(id){return lerp_registry.delay[id]}\n/**\n * Sets the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay value for the animation.\n */\nfunction set_delay(id,val){\n    lerp_registry.delay[id]=val\n}\n\n\n/**\n * Retrieves the current delay progress value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current delay progress value of the animation.\n */\nfunction get_delay_delta(id){\n    return lerp_registry.delay_delta[id]}\n/**\n * Sets the current delay progress value for an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay progress value for the animation.\n */\nfunction set_delay_delta(id,val){lerp_registry.delay_delta[id]=val}\n/**\n * Sets the sequence length of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired sequence length for the animation.\n */\nfunction set_sequence_length(id,val){lerpChain_registry.lengths[id]=val}\n/**\n * Retrieves a specific row from a matrix constant.\n * @param {number} id - The identifier for the matrix constant.\n * @param {number} row - The index of the row to retrieve from the matrix constant.\n * @returns {Array} - The specified row from the matrix constant.\n */\nfunction get_constant_row(id,row){return constant_registry.get_row(id,row)}\n\n/**\n * Retrieves a constant number value by its identifier.\n * @param {number} id - The identifier for the constant number.\n * @returns {number} - The constant number value associated with the given identifier.\n */\nfunction get_constant_number(id){return constant_registry.get_number(id)}\n/**\n * Retrieves an array of all active animation identifiers.\n * @returns {Array<number>} - An array of active animation identifiers.\n */\nfunction get_active(id){return lerp_registry.activelis}\n/**\n * Retrieves a boolean indicating whether the animation loop is currently running.\n * @returns {boolean} - true if the animation loop is currently running, false otherwise.\n */\nfunction get_status(){\n    return loop_resolver!=null\n}\n\n\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n// this has to commented out when creating the docs\nexport {\n    get_status,\n    addTrigger,removeTrigger,\n    get_time,set_delta_t,\n    get_step,set_step,\n    is_active,get_active,\n    start_animations,stop_animations,\n    setLerp,setMatrix,\n    get_lerp_value,\n    soft_reset,hard_reset,\n    get_duration,set_duration,\n    set_sequence_length,\n    change_framerate,\n    get_constant,get_constant_number,get_constant_row,render_constant,\n    update_constant,\n    set_delay,get_delay,\n    get_delay_delta,set_delay_delta,\n    lambda_call,\n}\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n// const eslapsed = performance.now() - startTime;\n// const waitTime = Math.max(0, fps - elapsed);\n// postMessage({\n//     message: \"finish\",\n//     results: lerp_registry.results,\n//     result_indices: lerp_registry.activelist\n// });\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n// }\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","signal","loop_resolver","triggers_step","callback_map","Map","Lerp","constructor","this","type","undefined","delta_t","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","loop","activelist","results","lerp_callbacks","activate","id","includes","push","index","final_step","final_sub_step","LerpChain","buffer","matrixChains","lengths","update_progress","reset_and_update","lerp_registry","reset","set","lerpChain_registry","soft_reset","Constant","matrices","numbers","matrix","number","render_triggers","render_callbacks","update","value","constant_registry","has","map","l","console","log","args","start_animations","row","get_row","get_number","trigger_registry","t","targets","allow_render","startTime","timeoutId","smoothLerp","min","max","v","amount","x","async","animate","val","i","length","step","time","target","animateLoop","AbortController","addEventListener","clearTimeout","aborted","performance","now","render","filter","active","stop_loop","Promise","resolve","reject","setTimeout","Math","start_loop","abort","indices","stop_animations","reset_animations","stopped","postMessage","message","result_indices","change_framerate","fps_new","integers","init","new_fps","lerps","lerpChains","triggers","constants","condi_new","springs","forEach","trigger","eval","arr","name","Float32Array","array","Uint8Array","m","i2","addTrigger","newtriggers","Array","warn","concat","removeTrigger","targetId","indexOf","splice","values","lambda_call","render_constant","get_constant","setLerp","setMatrix","update_constant","get_time","is_active","get_step","get_lerp_value","hard_reset","set_delta_t","set_step","get_duration","set_duration","get_delay","set_delay","get_delay_delta","set_delay_delta","set_sequence_length","get_constant_row","get_constant_number","get_active","activelis","get_status","onmessage","event","data","method","chain_map","matrix_chain_map","trigger_map","spring_map","callback","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}