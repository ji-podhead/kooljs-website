{"version":3,"file":"static/js/480.f465adb8.chunk.js","mappings":"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","sources":["../../../kooljs/kooljs/worker_utils.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../../../kooljs/kooljs/worker.js"],"sourcesContent":["// Copyright (c) 2025 Ji-Podhead and Project Contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n// 1. All commercial uses of the Software must:\n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).\n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nvar type,trigger,newtriggers\nvar group,distance, duration;\nclass Worker_Utils{\n\n\n/**\n * Adds a trigger to the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, it is created.\n * If the trigger does exist, the target is added to the existing trigger.\n * @param {number} id - The id of the animation to add the trigger to.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\n addTrigger({id, target, step, time}) {\n    if (this.trigger_registry.get(id) == undefined) {\n        this.trigger_registry.set(id, new Map());\n    }\n    if (this.trigger_registry.get(id).get(step) == undefined) {\n        this.trigger_registry.get(id).set(step, new Map());\n        this.trigger_registry\n            .get(id)\n            .get(step)\n            .set(time, new Uint8Array([target]));\n    } else if (this.trigger_registry.get(id).get(step).get(time) == undefined) {\n        this.trigger_registry\n            .get(id)\n            .get(step)\n            .set(time, new Uint8Array([target]));\n    } else {\n        trigger = this.trigger_registry.get(id).get(step).get(time);\n        if (trigger.includes(target) == false) {\n             newtriggers = new Array(trigger);\n            newtriggers.push(target);\n            newtriggers = new Uint8Array(newtriggers);\n            this.trigger_registry.get(id).get(step).set(time, newtriggers);\n        } else {\n            console.warn(\n                `trigger already exists: target ${target} in timeframe ${time} in step ${step} on animation with id ${id}`\n            );\n        }\n    }\n}\n/**\n * Removes a trigger from the trigger registry.\n * If the trigger does not exist at the given time and step in the given animation, a warning is printed.\n * If the trigger does exist, the target is removed from the existing trigger.\n * If the trigger is empty after removal (i.e. it only contained the target), the trigger is removed.\n * @param {number} id - The id of the animation to remove the trigger from.\n * @param {number} target - The target of the trigger.\n * @param {number} step - The step of the trigger.\n * @param {number} time - The time of the trigger.\n */\n removeTrigger({id, target, step, time}) {\n    trigger = this.trigger_registry.get(id).get(step)\n    if (trigger != undefined) {\n        if (trigger.get(time) != undefined) {\n            trigger = trigger.get(time);\n        } else {\n            return console.warn(\n                \"the slected timeframe in the  step does not include the target\"\n            );\n        }\n    } else {\n        return console.warn(\"the trigger registr has does not include the step\");\n    }\n    const targetId = trigger.indexOf(target);\n    if (targetId != undefined && trigger.length > 1) {\n        const newtriggers = new Uint8Array(new Array(trigger).splice(targetId, 1));\n        console.log(\n            `removed trigger target ${target} in timeframe ${time} in step ${step} from from id ${id}`\n        );\n        this.trigger_registry.get(id).get(step).set(time, newtriggers);\n    } else {\n        this.trigger_registry.get(id).get(step).set(time, undefined);\n    }\n    // else{\n    //     this.trigger_registry.get(id).set(step,undefined)\n    // }\n}\n update(type, values) {\n    values.map((x) => {\n        if (this.sequence_registry.lengths[x.id] != x.values.length - 1) {\n            if (this.lerp_registry.loop[x.id] == 1) {\n                this.removeTrigger(\n                   {id:x.id,\n                    target:x.id,\n                    step:this.sequence_registry.lengths[x.id] - 1,\n                    time:this.lerp_registry.duration[x.id]}\n                );\n                this.addTrigger(\n                    {\n                    id:x.id,\n                    target:x.id,\n                    step:x.values.length - 2,\n                    time:this.lerp_registry.duration[x.id]}\n                );\n                //this.trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n            }\n            this.sequence_registry.lengths[x.id] = x.values.length - 1;\n        }\n        if (type == 2) {\n            x.values.map((val, i) => {\n                this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[x.id] + i] =\n                    val;\n            });\n        } else if (type == 3) {\n            x.values.map((val, i) => {\n                this.sequence_registry.matrix_sequences.get(x.id).set(i, val);\n            });\n        }\n        this.sequence_registry.reset(x.id);\n    });\n}\n\n/**\n * Calls a lambda  stored in callback_map with the given id and arguments.\n * @param {number} id - The id of the lambda  to call\n * @param {any[]} args - The arguments to pass to the lambda \n */\n lambda_call(id, args) {\n    try {\n        // console.log(args)\n        // console.log(id)\n        return this.callback_map.get(id)(args);\n    } catch (err) {\n        console.error(\"error in lambda call\", id);\n        console.error(this.callback_map.get(id));\n        console.error(err);\n    }\n}\n// ----------------------------------------> EVENTS <--\n\n\n start_loop() {\n    if (this.loop_resolver == null) {\n        this.animateLoop();\n    }\n}\nstop_loop() {\n    if (this.loop_resolver != null) {\n        this.loop_resolver.abort();\n        this.loop_resolver = null;\n    }\n}\n/**\n * starts a list of animations\n * @param {Array<number>} indices an array of ids of the animations to start\n */\n  start_animations(indices) {\n    indices.map((id) => {\n        this.lerp_registry.delete_group_member(id)\n        this.sequence_registry.soft_reset(id);\n    });\n    this.start_loop();\n}\n/**\n * stops a list of animations\n * @param {Array<number>|string} indices an array of ids of the animations to stop; if \"all\", stops all animations\n */\n\n  stop_animations(indices) {\n    if (indices === \"all\") {\n        this.lerp_registry.stop_all();\n        this.stop_loop();\n    }\n    else {\n        indices.map((id) => {\n            this.lerp_registry.deactivate(id);\n        });\n    \n    if (this.lerp_registry.active_numbers.length == 0&&\n        this.lerp_registry.active_timelines.size == 0&&\n        this.lerp_registry.active_matrices.size == 0&&\n        this.lerp_registry.active_groups.size == 0\n    ) {\n        this.stop_loop();\n    }\n}\n}\n/**\n * Resets a list of animations.\n *\n * If \"all\" is passed, stops the animation loop and resets all active animations.\n * Otherwise, resets each animation in the provided indices, re-activates it, and\n * updates the results based on its type. If any animations were stopped and reset,\n * a render message is posted with the updated results.\n *\n * @param {Array<number>|string} indices - An array of animation IDs to reset, or \"all\" to reset all animations.\n */\n\n    reset_animations(indices) {\n    if (indices == \"all\") {\n        if(this.sequence_registry!=undefined){this.sequence_registry.stop_loop()}\n        else {this.stop_loop()}\n        indices = this.lerp_registry.type.map((t,i)=>{return i});\n    }\n    //stop_animations(indices)\n    var stopped=0\n    const results={\n        number_results: new Map(),\n        matrix_results: new Map(),\n    }\n    //this.sequence_registry.hard_reset(indices);\n    indices.map((x) => {\n        this.sequence_registry.reset(x);\n        this.lerp_registry.activate(x);\n            \n            switch (this.lerp_registry.type[x]) {\n                case 2:\n                    results.number_results.set(x,this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[x]])\n                    stopped+=1\n                    break;\n                case 3:\n                        results.matrix_results.set(\n                            x,\n                            this.sequence_registry.matrix_sequences.get(x).get(0)\n                        );\n                        stopped+=1\n                    break;\n                default:\n                    break;\n            }\n    });\n    if ( this.loop_resolver == null&&stopped> 0)\n        postMessage({\n            message: \"render\",\n            number_results: results.number_results,\n            matrix_results: results.matrix_results,\n        });\n}\n/**\n * Changes the framerate of the animation loop.\n *\n * @param {number} fps_new - The new framerate in frames per second.\n */\n  change_framerate(fps_new) {\n    this.fps = fps_new;\n}\n/**\n * This  can be called by the worker when a constant value is changed.\n * The main thread will receive a message with the changed value.\n * @param {number} id - the id of the constant\n * @param {number} type - the type of the constant (0 = number, 1 = matrix)\n */\n  render_constant(id, type) {\n    postMessage({\n        message: \"render_constant\",\n        id: id,\n        type: type,\n        value: get_constant(id, type),\n    });\n}\n\n// ----------------------------------------> User API <--\n\n/**\n * Sets a Lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number} value - the value to set\n */\n setLerp(index, step, value) {\n    //console.log(lerpChain_registry.buffer[this.lerp_registry.lerp_chain_start[index]+step])\n    this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[index] + step] =\n        value;\n}\n/**\n * Sets the matrix lerp target value for a certain step of an animation.\n * @param {number} index - the index of the animation\n * @param {number} step - the step for which the value should be set\n * @param {number[]} value - the matrix to set. The matrix is a 1 dimensional array of floats with a length that is a multiple of 4 (e.g. [r1, g1, b1, a1, r2, g2, b2, a2])\n */\n setMatrix(index, step, value) {\n    // console.log(lerpChain_registry.matrixChains.get(index).get(step))\n    value.map((x, i) => {\n        this.sequence_registry.matrix_sequences.get(index).get(step)[i] = x;\n    });\n    // lerpChain_registry.matrixChains.get(index).get(step)\n}\n/**\n * Updates a constant value.\n * @param {number} id - the id of the constant to update\n * @param {string} type - the type of the constant (number or matrix)\n * @param {number | number[]} value - the new value of the constant\n */\n update_constant(id, type, value) {\n    this.constant_registry.update(type, id, value);\n}\n/**\n * Gets a constant value.\n * @param {number} id - the id of the constant\n * @param {string} type - the type of the constant (number or matrix)\n * @returns {number | number[]} value - the value of the constant\n */\n get_constant(id, type) {\n    return this.constant_registry.get(type, id);\n}\n/**\n * Gets the current progress of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current progress value of the animation.\n */\n get_time(id) {\n    return this.lerp_registry.progress[id];\n}\n/**\n * Checks if an animation is currently running.\n * @param {number} id - The identifier for the animation.\n * @returns {boolean} - true if the animation is currently running, false otherwise.\n */\n\n is_active(id) {\n    if(!this.lerp_registry.active_groups.has(this.lerp_registry.group.has(id)) || !this.lerp_registry.active_group_indices.get(this.lerp_registry.group.get(id)).has(id)){\n    type=this.lerp_registry.type[id]\n    switch(type){\n        case(2 | 3):\n        return this.lerp_registry.active_numbers.includes(id);\n        case(3):\n        return this.lerp_registry.active_matrices.has(id)\n    }\n} else {return this.lerp_registry.active_group_indices.get(this.lerp_registry.group.get(id)).has(id)}\n    \n}\n/**\n * Gets the current step of the animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current step value of the animation.\n */\n get_step(id) {\n    return this.sequence_registry.progress(id);\n}\n/**\n * Gets the lerp result value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The lerp result value of the animation.\n */\n\n get_lerp_value(id) {\n    type=this.lerp_registry.type[id]\n    group=this.lerp_registry.group.get(id)\n    if(!group || !this.lerp_registry.active_groups.has(id))\n    switch(type){\n        case(2):  return this.lerp_registry.number_results.get(id);\n        case(3): return this.lerp_registry.matrix_results.get(id)\n    }\n    else{\n        return this.lerp_registry.active_group_indices.get(group).has(id)\n    }\n    \n}\n/**\n * Starts and resets an animation if its finished, or not playing.\n * @param {number} id - The identifier for the animation.\n */\n soft_reset(id) {\n    this.sequence_registry.soft_reset(id);\n}\n/**\n * Starts and resets an animation.\n * @param {number} id - The identifier for the animation.\n */\n hard_reset(id) {\n    this.sequence_registry.reset(id);\n}\n/**\n * Sets the current progress of an animation and updates the delta t value accordingly.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The new progress value for the animation.\n */\n set_time(id, val) {\n    this.lerp_registry.progress = val;\n}\n/**\n * Sets the current step of an animation.\n * If the provided step value exceeds the maximum length of the animation, it will be set to the maximum length.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired step value for the animation.\n */\n\n set_step(id, val) {\n    this.sequence_registry.progress[id] =\n        val > this.sequence_registry.lengths[id] ? this.sequence_registry.lengths[id] : val;\n}\n\n set_sequence_start(id, val) {\n    this.lerp_registry.lerp_chain_start[id] = val;\n}\n get_sequence_start(id) {\n    return this.lerp_registry.lerp_chain_start[id];\n}\n set_sequence_length(id, val) {\n    this.sequence_registry.lengths[id] = val;\n}\n\n get_sequence_length(id) {\n    return this.sequence_registry.lengths[id];\n}\n/**\n * Retrieves the target value for a specific step of an animation.\n *\n * This  determines the type of the animation and returns the target value\n * for the specified step.\n *\n * @param {number} id - The identifier for the animation.\n * @param {number} step - The step for which to retrieve the target value.\n * @returns {number|number[]} - The target value for the specified step of the animation.\n */\n\n get_step_lerp_target_value(id, step) {\n    if (this.lerp_registry.type[id] == 2)\n        return this.sequence_registry.buffer[this.lerp_registry.lerp_chain_start[id] + step];\n    else if (this.lerp_registry.type[id] == 3)\n        return this.sequence_registry.matrix_sequences.get(id).get(step);\n}\n\n/**\n * Gets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The duration of the animation.\n */\n get_duration(id) {\n    return this.lerp_registry.duration[id];\n}\n/**\n * Sets the duration of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired duration value for the animation.\n */\n set_duration(id, val) {\n    this.lerp_registry.duration[id] = val;\n}\n/**\n * Retrieves the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The delay value of the animation.\n */\n\n get_delay(id) {\n    return this.lerp_registry.delay[id];\n}\n/**\n * Sets the delay of an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay value for the animation.\n */\n set_delay(id, val) {\n    this.lerp_registry.delay[id] = val;\n}\n\n/**\n * Retrieves the current delay progress value of an animation.\n * @param {number} id - The identifier for the animation.\n * @returns {number} - The current delay progress value of the animation.\n */\n get_delay_delta(id) {\n    return this.lerp_registry.delay_delta[id];\n}\n/**\n * Sets the current delay progress value for an animation.\n * @param {number} id - The identifier for the animation.\n * @param {number} val - The desired delay progress value for the animation.\n */\n set_delay_delta(id, val) {\n    this.lerp_registry.delay_delta[id] = val;\n}\n\n/**\n * Retrieves a specific row from a matrix constant.\n * @param {number} id - The identifier for the matrix constant.\n * @param {number} row - The index of the row to retrieve from the matrix constant.\n * @returns {Array} - The specified row from the matrix constant.\n */\n get_constant_row(id, row) {\n    return this.constant_registry.get_row(id, row);\n}\n\n/**\n * Retrieves a constant number value by its identifier.\n * @param {number} id - The identifier for the constant number.\n * @returns {number} - The constant number value associated with the given identifier.\n */\n get_constant_number(id) {\n    return this.constant_registry.get_number(id);\n}\n/**\n * Retrieves an array of all active animation identifiers.\n * @returns {Array<number>} - An array of active animation identifiers.\n */\n get_active_group_indices(group){\n    return this.lerp_registry.active_groups.get(group)\n}\n get_active(type) {\n    switch(type){\n        case(2):\n            return this.lerp_registry.active_numbers\n        case(3):return this.lerp_registry.active_matrices;\n        case(4): return this.lerp_registry.active_timelines\n}\n}\n/**\n * Retrieves a boolean indicating whether the animation loop is currently running.\n * @returns {boolean} - true if the animation loop is currently running, false otherwise.\n */\n get_status() {\n    return this.loop_resolver != null;\n}\n\n/**\n * Replaces the target value for a specific step of an animation with a new one.\n *\n * If the animation type is not a matrix-chain, the  will set the lerp values\n * at the specified step and step + direction accordingly.\n *\n * If the animation type is a matrix-chain, the  will set the matrix values\n * at the specified step and step + direction accordingly.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number} opts.step - The step for which to reorient the target value.\n * @param {number} opts.direction - The direction (+1 or -1) in which to reorient the target value.\n * @param {number|number[]} opts.reference - The new target value to set for the animation.\n * @param {number[]} opts.matrix_row - The matrix row to set as the new target value.\n * @param {boolean} opts.verbose - Whether to log information about the reorientation process.\n */\n reorient_target({\n    index,\n    step=0,\n    direction=1,\n    reference,\n    matrix_row = 0,\n    start_reference,\n    verbose = false,\n\n}) {\n    verbose && console.log(\"replacing indices \" + index);\n    if (this.lerp_registry.type[index] != 2) {\n        if(start_reference){\n            this.setMatrix(index, step, start_reference);\n        }\n        else{\n            this.setMatrix(index, step, this.get_lerp_value(index));\n        }\n        this.setMatrix(index, step + direction, reference, matrix_row);\n    } else {\n        this.setLerp(index, step, reference);\n        this.setLerp(index, step + direction, matrix_row);\n    }\n//    verbose && console.log(\"reoriented animation with index \" + index);\n}\n\n/**\n * Reorients the duration of an animation.\n *\n * If min_duration is given, the  will soft_reset the animation and set its duration to the minimum of max_duration and max_duration - current_time + min_duration.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number} opts.min_duration - The minimum duration of the animation.\n * @param {number} opts.max_duration - The maximum duration of the animation.\n * @param {boolean} opts.verbose - Whether to log information about the reorientation process.\n */\n reorient_duration({\n    index,\n    min_duration,\n    max_duration,\n    verbose = false,\n}) {\n    if (min_duration != undefined) {\n        this.soft_reset(index);\n        const time = this.is_active(index) ? this.get_time(index) : 0;\n        const duration =\n            time < min_duration ? Math.floor(max_duration - time) : max_duration;\n        this.set_duration(index, duration);\n        verbose &&\n            console.log(\"new start_duration for \" + index + \" is \" + duration);\n    }\n}\n lerp(value, target, min, max, threshold) {\n    const t = (value - min) / (max - min);\n    const result = target * t + (1 - t) * threshold;\n    return result;\n}\n normalizeDistance(target, current, max) {\n    const distance = Math.abs(current - target);\n    return distance / Math.abs(max - target);\n}\n clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Reorients the duration of an animation based on the distance between the current value\n * and a target value.\n *\n * @param {object} opts - An object containing the following properties:\n * @param {number} opts.index - The index of the animation to reorient.\n * @param {number|number[]} opts.target - The target value towards which to reorient the animation.\n * @param {number} opts.max_distance - The max distance.\n * @param {number} opts.min_duration - The minimum duration of the animation.\n * @param {number} opts.max_duration - The maximum duration of the animation.\n * @param {string} opts.mode - The mode to use for calculating the distance. Possible values are \"max_distance\",\n *                             \"manhattan_distance\", \"cosine_similarity\", and \"vector_magnitude\".\n *\n * @returns {number} - The new duration of the animation.\n */\n reorient_duration_by_distance({\n    index,\n    target,\n    max_distance,\n    min_duration,\n    max_duration,\n    mode = \"max_distance\",\n}) {\n    const current = this.get_lerp_value(index);\n\n    if (this.lerp_registry.type[index] != 2) {\n        switch (mode) {\n            case \"max_distance\":\n                const distances = [];\n                for (let i = 0; i < target.length; i++) {\n                    distances.push(Math.abs(target[i] - current[i]));\n                }\n                distance = Math.max(...distances);\n                break;\n            case \"manhattan_distance\":\n                distance = 0;\n                for (let i = 0; i < target.length; i++) {\n                    distance += Math.abs(target[i] - current[i]);\n                }\n                break;\n            case \"cosine_similarity\":\n                const dotProduct = 0;\n                const magnitudeTarget = 0;\n                const magnitudeCurrent = 0;\n                for (let i = 0; i < target.length; i++) {\n                    dotProduct += target[i] * current[i];\n                    magnitudeTarget += target[i] ** 2;\n                    magnitudeCurrent += current[i] ** 2;\n                }\n                magnitudeTarget = Math.sqrt(magnitudeTarget);\n                magnitudeCurrent = Math.sqrt(magnitudeCurrent);\n                distance = 1 - dotProduct / (magnitudeTarget * magnitudeCurrent);\n                break;\n            case \"vector_magnitude\":\n                distance = 0;\n                for (let i = 0; i < target.length; i++) {\n                    distance += (target[i] - current[i]) ** 2;\n                }\n                distance = Math.sqrt(distance);\n                break;\n            default:\n                throw new Error(`Unbekannter Modus: ${mode}`);\n        }\n    } else if (this.lerp_registry.type[index] == 2)\n        distance = Math.abs(target - max_distance);\n    duration =\n        min_duration + (distance / max_distance) * (max_duration - min_duration);\n    //Math.min(max_duration, Math.max(min_duration, distance * max_distance));\n    this.soft_reset(index);\n    this.set_duration(index, duration);\n    return duration;\n}\n reorient_duration_by_progress({ index, min_duration, max_duration,soft_reset=true }) {\n    const progress = this.get_time(index) / max_duration;\n\n    duration = min_duration + progress * (max_duration - min_duration);\n    //Math.min(max_duration, Math.max(min_duration, distance * max_distance));\n    if(soft_reset){\n        this.soft_reset(index);\n    }\n    else{\n        \n    }\n    this.set_duration(index, duration);\n    return duration;\n}\n/**\n * Reverses the order of the lerp or matrix values in the animation sequence.\n *\n * @param {number|string} id - The identifier for the animation or the lerp-chain to reverse.\n *\n * @category Animation\n */\n reverse(id) {\n    if (type(id) != \"number\") {\n        for (\n            let i = this.lerp_registry.lerp_chain_start[id];\n            i <= this.lerp_registry.lerp_chain_start[id] + this.sequence_registry.lengths[id];\n            i++\n        ) {\n            this.sequence_registry.buffer[this.sequence_registry.lengths[id] - i] =\n                this.sequence_registry.buffer[i];\n        }\n    } else {\n        const newMap = new Map();\n        this.sequence_registry.matrix_sequences.get(id).forEach((val, i) => {\n            newMap.set(this.sequence_registry.lengths[id] - i, val);\n        });\n        this.sequence_registry.matrix_sequences.set(id, newMap);\n    }\n}\nreverse_group_delays(id){\n    this.matrix_chain_registry.indices.get(id).map((val,i)=>{\n        // if(i==this.matrix_chain_registry.indices.get(id).length-1){\n        //     return\n        // }\n        const target_index=this.matrix_chain_registry.indices.get(id).length-i\n        const target=this.matrix_chain_registry.indices.get(id)[target_index-1]\n        const target_delay=this.get_delay(target)\n        this.set_delay(target,this.get_delay(val))\n        this.set_delay(val,target_delay)\n    })\n}\nset_group_orientation(id,orientation){  \n    this.matrix_chain_registry.orientation_step.set(id,orientation)\n}\n    /**\n * Starts an animation sequence for a matrix chain.\n *\n * @param {number[]} directions - The directions for the animation sequence.\n * @param {number[]} indices - The indices for the animation sequence.\n *\n * @category Animation\n */\nstart_group(directions, indices,reorientate,use_start_reference) {\n    indices.map((indices2,i)=>{\n        if(!this.lerp_registry.active_groups.has(i)){\n        this.matrix_chain_registry.start_matrix_chain(directions[i],indices2,reorientate,use_start_reference)\n        }\n        // this.start_animations(this.matrix_chain_registry.indices.get(indices2))\n    })\n    this.start_loop();\n}\n\nstop_group(indices) {\n    if(indices==\"all\"){\n        \n        indices=[...this.lerp_registry.active_groups]\n    }\n    indices.map((id,i)=>{\n    if(this.lerp_registry.active_groups.has(id)){\n        this.lerp_registry.active_groups.delete(id)\n        this.lerp_registry.active_group_indices.get(id).clear() \n        this.matrix_chain_registry.progress[id]=0\n        this.stop_animations(this.matrix_chain_registry.indices.get(id))\n    }\n\n    })\n}\nget_group_values(id){\n    return{\n        active:this.lerp_registry.active_groups.has(id),\n        progress:this.matrix_chain_registry.progress[id],\n        orientation:this.matrix_chain_registry.orientation_step.get(id),\n        active_indices:this.lerp_registry.active_group_indices.get(id),\n        loop:this.matrix_chain_registry.group_loop[id]\n    }\n}\nset_group_values(id,field,value,step){\n    switch(field){\n        case \"max_duration\":\n            this.matrix_chain_registry.max_duration[id]=value\n            break;\n        case \"min_duration\":\n            this.matrix_chain_registry.min_duration[id]=value\n            break;\n        case \"progress\":\n            this.matrix_chain_registry.progress[id]=value\n            break;\n        case \"sequence_length\":\n            this.matrix_chain_registry.sequence_length[id]=value\n            break;\n        case \"group_loop\":\n            this.matrix_chain_registry.group_loop[id]=value\n        case \"orientation_step\":\n            this.matrix_chain_registry.orientation_step.set(id,value)\n            break;\n        case \"ref_matrix\":\n            if(this.matrix_chain_registry.uni_size[id]==1){\n                this.matrix_chain_registry.ref_matrix.get(id).get(step).map((x,i)=>{\n                    this.matrix_chain_registry.ref_matrix.get(id).get(step)[i]=value[i]\n                })\n                }\n            else{\n                const size=this.matrix_chain_registry.max_length[id]\n                this.matrix_chain_registry.ref_matrix.get(id).set(id*size+step).map((x,i)=>x=   value[i])\n            }\n            \n            break;\n    }\n}\n}\nexport{\nWorker_Utils\n}\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n// 1. All commercial uses of the Software must:\n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).\n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nimport { Worker_Utils } from \"kooljs/worker_utils\";\nvar triggers_step, animator, active_index, triggers_step\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp extends Worker_Utils {\n    constructor(results, callback_map, type, duration, render_interval, delay, delay_delta, progress, smoothstep, lerp_chain_start, loop, group, group_lookup, lerp_callback_ids) {\n        super()\n        this.type = type\n        this.duration = duration\n        this.matrix_chain_groups = undefined\n        this.render_interval = render_interval\n        this.delay_delta = delay_delta\n        this.delay = delay\n        this.progress = progress\n        this.smoothstep = smoothstep\n        this.matrix_chain_registry = undefined\n        this.lerp_chain_start = lerp_chain_start\n        this.loop = loop\n        this.group = group\n        this.group_lookup = group_lookup\n        this.active_groups = new Set()\n        this.active_group_indices = new Map()\n        this.active_timelines = new Set()\n        this.active_matrices = new Set()\n        this.active_numbers = []\n        this.active_group_indices_render = new Map()\n        this.group_results_render = new Map()\n        this.matrix_results_render = new Map()\n        this.number_results_render = new Map()\n        this.matrix_results = results.get(\"matrix_results\")\n        this.number_results = results.get(\"number_results\")\n        this.group_results = new Map()\n        this.lerp_callbacks = new Map();\n        this.loop_resolver = null;\n        lerp_callback_ids.forEach((val, key) => {\n            // no shallow copy just copying the pointer\n            this.lerp_callbacks.set(key, callback_map.get(val));\n        });\n    }\n    activate(id) {\n        switch (this.type[id]) {\n            case (2):\n                if (this.active_numbers.includes(id) == false) {\n                    this.active_numbers = Uint8Array.from([...this.active_numbers, id])\n                    this.number_results_render.delete(id)\n                    return false\n                }\n                else {\n                    return true\n                }\n            case (3):\n                //if(this.group.has(id)!=true){\n                if (this.active_matrices.has(id) == false) {\n                    this.active_matrices.add(id)\n                    this.matrix_results_render.set(id, new Map())\n\n                    return false\n                }\n                else {\n                    return true\n                }\n            case (4):\n                if (this.active_timelines.has(id) == false) {\n                    this.active_timelines.add(id)\n                    return false\n                }\n                else {\n                    return true\n                }\n        }\n    }\n    delete_group_member(id) {\n        if (this.group.has(id)) {\n            const group = this.group.get(id)\n            if (this.active_groups.has(group)) {\n                this.active_group_indices.get(group).delete(id)\n                this.group_results_render.get(group).delete(this.group_lookup.get(id))\n                if (this.active_group_indices.get(group).size == 0) {\n                    this.matrix_chain_registry.update_group(group)\n                }\n                return true\n            }\n            return false\n        }\n        else { return false }\n    }\n    deactivate(id) {\n        switch (this.type[id]) {\n            case (3):\n                if (this.delete_group_member(id) == false) {\n                    this.active_matrices.delete(id);\n                    this.matrix_results_render.delete(id);\n                }\n                break\n            case (2):\n                active_index = this.active_numbers.indexOf(id)\n                this.active_numbers = Uint8Array.from([...this.active_numbers.slice(0, active_index), ...this.active_numbers.slice(active_index + 1, this.active_numbers.length)])\n                this.number_results_render.delete(id)\n\n                break\n            case (4):\n                this.active_timelines.delete(id);\n        }\n    }\n    stop_all() {\n        this.active_numbers = []\n        this.active_matrices.clear()\n        this.active_timelines.clear()\n        this.active_groups.clear()\n        this.active_groups.forEach((val, key) => {\n            this.active_group_indices.get(key).clear()\n        })\n        this.group_results_render.clear()\n        this.matrix_results_render.clear()\n        this.number_results_render.clear()\n        // this.active_group_indices.forEach((val, key) => {\n        //     this.active_group_indices.set(key, [])\n        // })\n    }\n}\nconst default_target_step = [0, 1]\nvar final_step, final_sub_step;\nclass LerpSequence extends Worker_Utils {\n    /**\n     * The constructor for the LerpChain class.\n     * Initializes properties related to the state and progress of the lerp chain.\n     *\n     * @property {Array|undefined} buffer - The buffer holding the chain data.\n     * @property {Map|undefined} matrixChains - The map containing matrix chains.\n     * @property {Array|undefined} progress - The progress of each chain.\n     * @property {Array|undefined} lengths - The lengths of each chain.\n     */\n    constructor(buffer, matrix_sequences, progress, lengths, animator) {\n        super()\n        this.buffer = buffer\n        this.matrix_sequences = matrix_sequences\n        this.progress = progress\n        this.lengths = lengths\n        this.lerp_registry = animator.lerp_registry\n    }\n    update_progress(id) {\n        if (this.progress[id] == this.lengths[id] - 1) {\n            this.stop_animations([id])\n        } else {\n            this.reset_and_update(id);\n            return false;\n        }\n    }\n    reset_and_update(id) {\n        this.lerp_registry.delay_delta[id] = 0;\n        this.lerp_registry.progress[id] = 0;\n        this.progress[id] += 1;\n    }\n    reset(id) {\n        switch (this.lerp_registry.type[id]) {\n            case (2):\n                this.lerp_registry.number_results[id] = this.buffer[this.lerp_registry.lerp_chain_start[id]]\n                break\n            case (3):\n                if (!this.lerp_registry.group.get(id))\n                    this.lerp_registry.matrix_results.set(\n                        id,\n                        this.matrix_sequences.get(id).get(0)\n                    );\n                break\n        }\n        this.lerp_registry.delay_delta[id] = 0;\n        this.lerp_registry.progress[id] = 0;\n        this.progress[id] = 0;\n    }\n    soft_reset(id) {\n        if (this.lerp_registry.activate(id) == false) {\n            final_step = this.progress[id] == this.lengths[id] - 1;\n            final_sub_step = this.lerp_registry.progress[id] >= this.lerp_registry.duration[id];\n            if (final_step && final_sub_step) {\n                this.reset(id);\n            } else if (final_sub_step) {\n                this.reset_and_update(id);\n            }\n        }\n    }\n}\nvar indices\nclass Matrix_Chain extends Worker_Utils {\n    constructor(indices, ref_matrix, uni_size,orientation_step, max_duration, min_duration, custom_delay,  group_loop, max_length, sequence_length, animator) {\n        super()\n        this.indices = indices;\n        this.ref_matrix = ref_matrix;\n        this.orientation_step = orientation_step\n        this.max_duration = max_duration;\n        this.min_duration = min_duration;\n        this.uni_size=uni_size\n        this.max_length = max_length\n        this.custom_delay = custom_delay;\n        this.progress = new Uint8Array(indices.size).fill(0, 0, indices.length)\n        this.sequence_length = sequence_length\n        this.lerp_registry = animator.lerp_registry\n        this.group_loop = group_loop\n        this.sequence_registry = animator.sequence_registry\n        this.constant_registry = animator.constant_registry\n        this.lerp_registry = animator.lerp_registry\n        this.start_loop = animator.start_loop\n        this.callback_map = animator.callback_map\n        this.result_map = new Map()\n        indices.forEach((val, i) => {\n            this.lerp_registry.active_group_indices.set(i, new Set())\n            this.lerp_registry.group_results.set(i, new Map())\n            val.map((group, i2) => {\n                this.lerp_registry.group_results.get(i).set(i2, ref_matrix.get(i).get(i2))\n            })\n        })\n    }\n    reorient_matrix_chain({ id, target_step, direction,reorientate,use_start_reference }) {\n        var indices = this.indices.get(id)\n        indices.map((index, i) => {\n            var ref = this.ref_matrix.get(id)\n            var start_ref\n            const current = this.get_lerp_value(index);\n            var base\n            if(this.uni_size[id]=1){\n                base=0\n            }\n            else[\n                base = i * this.max_length[id]\n            ]\n            this.lerp_registry.active_group_indices.get(id).add(index)\n            if (use_start_reference)  {\n                start_ref = ref.get(target_step[direction==1?0:1] + base);\n            }\n            ref = ref.get(target_step[direction] + base);\n            if (ref == current) {\n                return console.log(\"target animation is reachead\");\n            }\n            this.hard_reset(index);\n            if(reorientate)this.reorient_target({\n                index: index,\n                step: 0, // this is alway zero, since the matrix itself has a steplength of 2, but the ref matrix lnegth can be bigger\n                direction: 1,\n                matrix_row: 0,\n                verbose: false,\n                reference: ref,\n                start_reference: start_ref\n\n            });\n            if (this.custom_delay[id] >= 0) {\n                const delay = (this.lambda_call(this.custom_delay[id], { animation_index: index, index: i, indices: indices, progress:this.progress[id],direction: direction, target_step: target_step }) || 0)\n                this.set_delay(index, delay);\n            }\n            if(reorientate==\"progress\")this.reorient_duration_by_progress({\n                index: index,\n                min_duration: this.min_duration[id],\n                max_duration: this.max_duration[id],\n                soft_reset: false\n            });\n        });\n    }\n    start_matrix_chain(direction, id,reorientate=\"progress\",use_start_reference) {\n        this.result_map.clear()\n        const target= this.orientation_step.get(id)// ? this.orientation_step.get(id) : default_target_step[direction == 0 ? 1 : 0]\n        this.lerp_registry.group_results_render.set(id, this.result_map)\n        //this.lerp_registry.active_group_indices_render.set(id,this.lerp_registry.active_group_indices.get(id))\n        this.reorient_matrix_chain({\n            id: id,\n            direction: direction,\n            target_step: target,\n            reorientate:reorientate,\n            use_start_reference:use_start_reference\n        })\n        this.lerp_registry.active_groups.add(id)\n    }\n    group_set( id) {\n        // this.progress.set(id,progress)\n        \n        const ref = this.ref_matrix.get(id)\n        this.indices.get(id).map((index, i) => {\n            var base\n            if(this.uni_size[id]=1){\n                base=0\n            }\n            else{\n                base = i * this.max_length[id]\n            }\n            const start_index = base + this.progress[id]\n            const end_index = base + this.progress[id] + 1\n            const start = ref.get(start_index)\n            const end = ref.get(end_index)\n\n            this.setMatrix(index, 0, start)\n            this.setMatrix(index, 1, end)\n            this.lerp_registry.active_group_indices.get(id).add(index)\n            this.hard_reset(index)\n        })\n        \n    }\n    update_group(id) {\n        this.progress[id] += 1\n        if (this.progress[id] >= this.sequence_length[id]) {\n            this.progress[id] = 0\n            if (this.group_loop[id] == 1) {\n                this.orientation_step.set(id, [0, 1])\n                if (this.sequence_length[id] == 1) {\n                    this.start_matrix_chain(1, id)\n                }\n                else {\n                    this.group_set(id)\n                }\n            }\n            else {\n                this.lerp_registry.active_groups.delete(id)\n            }\n        }\n        else {\n             this.group_set(id)\n        }\n    }\n}\nclass Constant extends Worker_Utils {\n    constructor(constants, animator) {\n        super()\n        this.reg = new Map()\n        this.reg.set(\"matrix\", new Map())\n        this.reg.set(\"number\", undefined)\n        this.render_triggers = new Map();\n        this.render_callbacks = new Map();\n        this.animator = animator\n        if (constants.get(\"matrix\") != undefined) {\n            constants.get(\"matrix\").forEach((val, i) => {\n                this.reg.get(\"matrix\").set(i, new Map());\n                val.map((m, i2) => {\n                    this.reg.get(\"matrix\").get(i).set(i2, new Float32Array(m));\n                });\n            });\n        }\n        if (constants.get(\"number\") != undefined) {\n            this.reg.set(\"number\", constants.get(\"number\"))\n        }\n        this.render_triggers = constants.get(\"render_triggers\");\n        this.render_callbacks = constants.get(\"render_callbacks\");\n    }\n    update(type, id, value) {\n        //[\"matrix\",\"number\"].includes[\"type\"]&&this.reg.get(type).has(id)&&\n        this.reg.get(type).set(id, value);\n        if (this.render_callbacks.has(id))\n            this.render_callbacks.get(id).map((l) => {\n                this.animator.callback_map.get(l.id)(l.args);\n            });\n        if (this.render_triggers.has(id))\n            this.animator.start_animations(this.render_triggers.get(id));\n    }\n    get(type, index, row) {\n        if (row != undefined) {\n            this.get_row(index, row);\n        } else return this.reg.get(type).get(index);\n    }\n    get_row(index, row) {\n        return this.reg.get(\"matrix\").get(index).get(row);\n    }\n    get_number(index) {\n        return this.reg.get(\"number\").get(index);\n    }\n}\n// ----------------------------------------> ANIMATION <--\nvar t;\nvar targets, allow_render, args, delta_t, res\nvar startTime, timeoutId\nvar indices, buffer\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v);\n    //  t=(t*amount)/t\n    return max * t + min * (1 - t);\n}\nfunction smoothstep(x) { return x * x * (3 - 2 * x) }\nclass Animator extends Worker_Utils {\n    constructor(new_fps, lerps, lerpChains, results, triggers, constants, condi_new, matrix_chains, springs) {\n        super()\n        this.fps = new_fps;\n        // this.buffer = buffer.transfer(buffer.byteLength);\n        // this.result_buffer = result_buffer;\n        this.callback_map = new Map();\n        this.trigger_registry = new Map();\n        this.callback_map = new Map();\n        this.update_group = undefined\n        triggers.forEach((trigger, key) => this.trigger_registry.set(key, trigger));\n        condi_new.forEach((val, key) => {\n            try {\n                this.callback_map.set(key, eval(val));\n            } catch (err) {\n                console.error(\n                    \"failed to eval callback function on the worker for: \" + key\n                );\n                console.error(val);\n                console.error(err);\n            }\n        });\n        this.lerp_registry = new Lerp(\n            results,\n            this.callback_map,\n            lerps.get(\"type\"),\n            lerps.get(\"duration\"),\n            lerps.get(\"render_interval\"),\n            lerps.get(\"delay\"),\n            lerps.get(\"delay_delta\"),\n            lerps.get(\"progress\"),\n            lerps.get(\"smoothstep\"),\n            lerps.get(\"lerp_chain_start\"),\n            lerps.get(\"loop\"),\n            lerps.get(\"group\"),\n            lerps.get(\"group_lookup\"),\n            lerps.get(\"lerp_callbacks\"),\n            this\n        )\n        this.sequence_registry = new LerpSequence(\n            lerpChains.get(\"buffer\"),\n            lerpChains.get(\"matrix_buffer\"),\n            lerpChains.get(\"progress\"),\n            lerpChains.get(\"lengths\"),\n            this\n        )\n        this.matrix_chain_registry = new Matrix_Chain(\n            matrix_chains.get(\"indices\"),\n            matrix_chains.get(\"ref_matrix\"),\n            matrix_chains.get(\"uni_size\"),\n            matrix_chains.get(\"orientation_step\"),\n            matrix_chains.get(\"max_duration\"),\n            matrix_chains.get(\"min_duration\"),\n            matrix_chains.get(\"custom_delay\"),\n            matrix_chains.get(\"group_loop\"),\n            matrix_chains.get(\"max_length\"),\n            matrix_chains.get(\"sequence_length\"),\n            this\n        )\n        this.update_group = this.matrix_chain_registry.update_group\n        this.lerp_registry.matrix_chain_registry = this.matrix_chain_registry\n        this.start_matrix_chain = this.matrix_chain_registry.start_matrix_chain\n        this.lerp_registry.matrix_chain_registry = this.matrix_chain_registry\n\n        this.constant_registry = new Constant(constants, this)\n        this.animateLoop = async function () {\n            try {\n                this.loop_resolver = new AbortController();\n                this.loop_resolver.signal.addEventListener(\"abort\", () => {\n                    clearTimeout(timeoutId);\n                });\n                while (this.loop_resolver.signal.aborted == false) {\n                    startTime = performance.now();\n                    this.lerp_registry.active_timelines.forEach((id) => this.animate(id))\n                    this.lerp_registry.active_numbers.map((id, i) =>\n                        this.animate(id, this.animate_number, this.lerp_registry.number_results, 2, i))\n                    this.lerp_registry.active_matrices.forEach((id) => this.animate(id, this.animate_matrix, this.lerp_registry.matrix_results, 3))\n                    this.lerp_registry.active_groups.forEach((group_id) => {\n                        this.lerp_registry.active_group_indices.get(group_id).forEach((id, i) => { this.animate(id, this.animate_matrix, this.lerp_registry.matrix_results, 0, group_id, i) })\n                    })\n                    this.render();\n                    if (this.lerp_registry.active_groups.size > 0\n                        || this.lerp_registry.active_timelines.size > 0\n                        || this.lerp_registry.active_matrices.size > 0\n                        || this.lerp_registry.active_numbers.length > 0\n                    ) {\n                        await new Promise((resolve, reject) => {\n                            timeoutId = setTimeout(() => {\n                                resolve();\n                            }, Math.max(0, this.fps - (performance.now() - startTime)));\n                        });\n                    } else {\n                        return this.stop_loop();\n                    }\n                }\n            } catch {\n                (err) => {\n                    this.stop_loop();\n                    this.stop_animations(\"all\");\n                    return Error(\"had a error during animation. stoppingloop! \" + err);\n                };\n            }\n        }\n        this.animate_matrix = ((id, delta_t, target) => {\n            //lookup = this.lerp_registry.a.get(id) != undefined ? this.lerp_registry.group_lookup.get(id) : id\n            for (let i = 0; i < this.sequence_registry.matrix_sequences.get(id).get(this.sequence_registry.progress[id]).length; i++) {\n                target.get(id)[i] = smoothLerp(\n                    this.sequence_registry.matrix_sequences\n                        .get(id)\n                        .get(this.sequence_registry.progress[id])[i],\n                    this.sequence_registry.matrix_sequences\n                        .get(id)\n                        .get(this.sequence_registry.progress[id] + 1)[i],\n                    delta_t,\n                    this.lerp_registry.smoothstep[id]\n                );\n            }\n        })\n        this.animate_number = ((id, delta_t, target, render_index) => {\n            target[id] = smoothLerp(\n                this.sequence_registry.buffer[\n                this.lerp_registry.lerp_chain_start[id] +\n                this.sequence_registry.progress[id]\n                ],\n                this.sequence_registry.buffer[\n                this.lerp_registry.lerp_chain_start[id] +\n                this.sequence_registry.progress[id] +\n                1\n                ],\n                delta_t,\n                this.lerp_registry.smoothstep[id]\n            )\n            this.lerp_registry.number_results_render.set(id, target[id])\n\n        })\n        this.animate = async function (index, method, target, type, reference) {\n            if (this.lerp_registry.progress[index] <= this.lerp_registry.duration[index]) {\n                if (this.lerp_registry.delay_delta[index] < this.lerp_registry.delay[index] - 1) {\n                    this.lerp_registry.delay_delta[index] += 1;\n                }\n                else if (this.lerp_registry.delay_delta[index] == 0 || (this.lerp_registry.delay_delta[index] < this.lerp_registry.delay[index])) {\n                    this.lerp_registry.delay_delta[index] += 1;\n                    if (method != undefined) {\n                        switch (type) {\n                            case (0):\n                                this.lerp_registry.group_results_render.get(reference).set(this.lerp_registry.group_lookup.get(index), this.lerp_registry.matrix_results.get(index))\n                                break\n                            case (2):\n                                this.lerp_registry.number_results_render.set(index, this.lerp_registry.number_results[index])\n                                break;\n                            case (3):\n                                this.lerp_registry.matrix_results_render.set(index, this.lerp_registry.matrix_results.get(index))\n                                break\n                        }\n                    }\n                }\n                else {\n                    allow_render = this.lerp_registry.progress[index] % this.lerp_registry.render_interval[index];\n                    if (allow_render == 0) {\n                        delta_t = this.lerp_registry.progress[index] / this.lerp_registry.duration[index];\n                        if (method != undefined) res = method(index, delta_t, target, reference)\n                        args = {\n                            id: index,\n                            value: res,\n                            step: this.sequence_registry.progress[index],\n                            time: this.lerp_registry.progress[index],\n                            step: this.sequence_registry.progress[index],\n                        };\n                        if (this.lerp_registry.lerp_callbacks.has(index)) {\n                            try {\n                                this.lerp_registry.lerp_callbacks.get(index)(args);\n                            }\n                            catch (err) { console.log(err) }\n                        }\n                    }\n                    this.lerp_registry.progress[index] += 1;\n                    if (allow_render == 0) {\n                        triggers_step =\n                            this.trigger_registry.get(index) != undefined\n                                ? this.trigger_registry.get(index).get(this.sequence_registry.progress[index])\n                                : undefined;\n                        if (triggers_step != undefined) {\n                            targets = triggers_step.get(this.lerp_registry.progress[index] - 1);\n                            targets && targets.map((target) => {\n                                if (target == index) {\n                                     this.hard_reset(target); this.lerp_registry.number_results_render.delete }\n                                else this.soft_reset(target);\n\n                            });\n                        }\n                    }\n                }\n            }\n            else { this.sequence_registry.update_progress(index) }\n        }\n        this.render = () => {\n            postMessage(\n                {\n                    message: \"render\",\n                    number_results: this.lerp_registry.number_results_render,\n                    matrix_results: this.lerp_registry.matrix_results_render,\n                    group_results: this.lerp_registry.group_results_render,\n                },\n            )\n            //this.result_buffer = result_buffer.transfer(result_buffer.byteLength);\n        }\n    }\n}\nvar const_map_new;\nonmessage = (event) => {\n    switch (event.data.method) {\n        case \"init\":\n            animator = new Animator(\n                event.data.fps,\n                event.data.data,\n                event.data.chain_map,\n                event.data.results,\n                event.data.trigger_map,\n                event.data.constants,\n                event.data.callback_map,\n                event.data.matrix_chain_map,\n                event.data.spring_map\n            );\n            break;\n        case \"update\":\n            animator.update(event.data.type, event.data.data);\n            break;\n        case \"update_constant\":\n            if (event.data.type == \"matrix\") {\n                const_map_new = new Map();\n                event.data.value.map((val, i) => {\n                    if (typeof val != \"\") {\n                        event.data.value[i] = new Float32Array(val);\n                    }\n                    const_map_new.set(i, event.data.value[i]);\n                });\n                animator.constant_registry.update(event.data.type, event.data.id, const_map_new);\n            } else {\n                animator.constant_registry.update(\n                    event.data.type,\n                    event.data.id,\n                    event.data.value\n                );\n            }\n            break;\n        case \"start\":\n            animator.start_loop();\n            break;\n        case \"set_lambda\":\n            animator.callback_map.set(event.data.id, eval(event.data.callback));\n            break;\n        case \"stop\":\n            animator.stop_loop();\n            break;\n        case \"change_framerate\":\n            animator.change_framerate(event.data.fps_new);\n            break;\n        case \"lambda_call\":\n            animator.lambda_call(event.data.id, event.data.args);\n            break;\n        case \"start_animations\":\n            animator.start_animations(event.data.indices);\n            break;\n        case \"stop_animations\":\n            animator.stop_animations(event.data.indices);\n            break;\n        case \"start_groups\":\n            animator.start_group(event.data.directions, event.data.indices,event.data.reorientate,event.data.use_start_reference);\n            break;\n        case \"stop_groups\":\n            animator.stop_group(event.data.indices);\n            break;\n        case \"set_group_orientation\":\n            animator.set_group_orientation(event.data.index, event.data.orientation);\n            break;\n        case \"reset_animations\":\n            animator.reset_animations(event.data.indices);\n            break;\n        case \"set_group\":{\n            animator.set_group_values(event.data.id, event.data.field,  event.data.value,event.data.step);\n        }\n        case \"addTrigger\":\n            animator.addTrigger({\n                id: event.data.id,\n                target: event.data.target,\n                step: event.data.step,\n                time: event.data.time\n            }\n            );\n            break;\n        case \"removeTrigger\":\n            animator.removeTrigger({\n                id: event.data.id,\n                target: event.data.target,\n                step: event.data.step,\n                time: event.data.time\n            }\n            );\n            break;\n        default:\n            console.warn(\"no method selected during worker call\");\n            break;\n    }\n};\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring {\n    constructor(elements, duration, spring_tension, spring_whatever) {\n        this.elements = elements;\n        this.duration = duration;\n        this.spring_tension = spring_tension;\n    }\n}\n//dijkstra algo fr matrix\nfunction shortest_path() { }\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn() { }\n//matrix and callback for lerp\nfunction convex_hull() { }\nfunction spring() { }\nexport {\n    Animator as animator, Lerp, Matrix_Chain, Constant, LerpSequence\n}\n\n// this has to commented out when creating the docs\n\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n// const eslapsed = performance.now() - startTime;\n// const waitTime = Math.max(0, fps - elapsed);\n// postMessage({\n//     message: \"finish\",\n//     results: this.lerp_registry.results,\n//     result_indices: this.lerp_registry.activelist\n// });\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: this.lerp_registry.results, result_indices: this.lerp_registry.activelist })\n// }\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n\n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n\n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n\n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n\n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedmpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // berdmpft\n//           y = x * Math.exp(-omega * t);\n//         }\n\n//         // Bounce-Effekt hinzufgen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n\n//         // Auslaufwert bercksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n\n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n\n//   const animations = calculateSpringAnimation(matrix, params);\n"],"names":["type","trigger","newtriggers","group","distance","duration","Worker_Utils","addTrigger","_ref","id","target","step","time","undefined","this","trigger_registry","get","set","Map","Uint8Array","includes","Array","push","console","warn","concat","removeTrigger","_ref2","targetId","indexOf","length","splice","log","update","values","map","x","sequence_registry","lengths","lerp_registry","loop","val","i","buffer","lerp_chain_start","matrix_sequences","reset","lambda_call","args","callback_map","err","error","start_loop","loop_resolver","animateLoop","stop_loop","abort","start_animations","indices","delete_group_member","soft_reset","stop_animations","stop_all","deactivate","active_numbers","active_timelines","size","active_matrices","active_groups","reset_animations","t","stopped","results","number_results","matrix_results","activate","postMessage","message","change_framerate","fps_new","fps","render_constant","value","get_constant","setLerp","index","setMatrix","update_constant","constant_registry","get_time","progress","is_active","has","active_group_indices","get_step","get_lerp_value","hard_reset","set_time","set_step","set_sequence_start","get_sequence_start","set_sequence_length","get_sequence_length","get_step_lerp_target_value","get_duration","set_duration","get_delay","delay","set_delay","get_delay_delta","delay_delta","set_delay_delta","get_constant_row","row","get_row","get_constant_number","get_number","get_active_group_indices","get_active","get_status","reorient_target","_ref3","direction","reference","matrix_row","start_reference","verbose","reorient_duration","_ref4","min_duration","max_duration","Math","floor","lerp","min","max","threshold","normalizeDistance","current","abs","clamp","reorient_duration_by_distance","_ref5","max_distance","mode","distances","dotProduct","magnitudeTarget","magnitudeCurrent","sqrt","Error","reorient_duration_by_progress","_ref6","reverse","newMap","forEach","reverse_group_delays","matrix_chain_registry","target_index","target_delay","set_group_orientation","orientation","orientation_step","start_group","directions","reorientate","use_start_reference","indices2","start_matrix_chain","stop_group","delete","clear","get_group_values","active","active_indices","group_loop","set_group_values","field","sequence_length","uni_size","ref_matrix","max_length","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","triggers_step","animator","active_index","Lerp","constructor","render_interval","smoothstep","group_lookup","lerp_callback_ids","super","matrix_chain_groups","Set","active_group_indices_render","group_results_render","matrix_results_render","number_results_render","group_results","lerp_callbacks","from","add","update_group","slice","default_target_step","final_step","final_sub_step","targets","allow_render","delta_t","res","startTime","timeoutId","const_map_new","LerpSequence","update_progress","reset_and_update","Matrix_Chain","custom_delay","fill","result_map","i2","reorient_matrix_chain","target_step","start_ref","ref","base","animation_index","arguments","group_set","start_index","end_index","start","end","Constant","constants","reg","render_triggers","render_callbacks","m","Float32Array","l","smoothLerp","v","amount","Animator","new_fps","lerps","lerpChains","triggers","condi_new","matrix_chains","springs","eval","async","AbortController","signal","addEventListener","clearTimeout","aborted","performance","now","animate","animate_number","animate_matrix","group_id","render","Promise","resolve","reject","setTimeout","_unused","render_index","method","onmessage","event","data","chain_map","trigger_map","matrix_chain_map","spring_map","callback","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}